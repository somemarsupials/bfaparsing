# -*- coding: utf-8 -*-

from .token import Token


class TreeView:

    def __init__(self, root, aggregate=[]):
        """ Create a TokenView based on the given token. A TokenView
        provides an easy means of traversing a parse tree.
        
        DETAILS OF METHODS?
        """
        # get attributes from root
        for item in dir(root):
            if not item.startswith('__') and not item.endswith('__'):
                setattr(self, item, getattr(root, item))
        self.value == Token.value
        self.root = root
        self.aggregate = aggregate

    def iter_treeview(self):
        """ Return the token's children as TreeView objects. """
        return list(map(TreeView, self.children))

    def flatten_list(self, token):
        """ Convert a token generated by recursion to a flat list of
        tokens. Returns a list.
        """
        out = []
        for c in token.children:
            if c.token_type == token.token_type:
                out.append(self.flatten_list(c))
            else:
                out.append(c)
        return out

    def flatten_token(self, token):
        """ Convert tokens created by recursive rules into a flat token.
        For example, a token created by the rule "a := b a | b" might
        create a token with the structure "a -> b a -> b", where "->"
        denotes children of tokens. The flatten would convert this to a
        token with children "a -> b b".
        """
        # create a new token with same type
        new = Token(token_type=token.token_type)
        # replace children with flattened children
        new.children = self.flatten_list(token)
        return new

    def flatten(self):
        """ Flatten the root token. """
        self.root = self.flatten_token(self.root)

    def tokens(self, aggregate=None, as_str=False):
        """ Get ordered tokens for the root token. See get_tokens for
        more information.
        """
        tokens = self.get_tokens(self.root, aggregate, as_str)
        return tokens

    def get_tokens(self, token, aggregate=None, as_str=False):
        """ Generate an ordered list of the lowest-level child tokens
        beneath the given token. In general, these should all be literal
        expressions.

        Use the aggregate option to specify a list of token types that
        should not be broken up. For example, 'word' made up of repeated
        'alpha' tokens is probably more useful as it is, rather than
        being given as a series of individual letters. Note that the
        TreeView may be created with a aggregate list which is used by
        default.

        Use the as_str option to return a list of strings instead of
        tokens.
        """
        # use the TreeView aggregation if none given
        if not aggregate:
            aggregate = self.aggregate
        output = []
        for c in token.children:
            # recursively call for tokens with children
            if c.has_under() and c.token_type not in aggregate:
                output.extend(self.get_tokens(c, aggregate, as_str))
            # otherwise return the token value
            else:
                output.append(c.value() if as_str else c)
        return output
        
    def find(self, token_type, as_str=False):
        """ Search the root's children for all instances of tokens
        with the given type. Return a list of tokens, or strings if
        as_str is True.
        """
        output = []
        for c in self.iter_treeview():
            if c.token_type == token_type:
                output.append(c.value() if as_str else c)
            output.extend(c.find(token_type, as_str=as_str))
        return output
    
    def level(self, index, token=None, as_str=False):
        """ Return all tokens at the given depth. For example, 0 returns
        the root, 1 returns the roots children, 2 all grand-children and
        so on. Defaults to the root token.
        """
        if not token:
            token = self.root
        output = []
        if index == 0:
            print(token)
            output.append(token)
        else:
            for c in token.children:
                output.extend(self.level(index - 1, c, as_str))
        return output

    def __getitem__(self, index):
        """ Return the indexed child. """
        return self.children[index]

    def __repr__(self):
        """ Show value and content of token. """
        return 'TreeView(%s: %s)' % (self.token_type, self.value())
