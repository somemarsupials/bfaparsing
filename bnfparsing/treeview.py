# -*- coding: utf-8 -*-

from types import MethodType
from .token import Token


class TreeView:

    def __init__(self, root, aggregate=[]):
        """ Create a TokenView based on the given token. A TokenView
        provides an easy means of traversing a parse tree.
        
        DETAILS OF METHODS?
        """
        self.value = root.value
        self.root = root
        self.aggregate = aggregate

    def iter_treeview(self):
        """ Return the token's children as TreeView objects. """
        return list(map(TreeView, self.children))

    def flatten_list(self, token):
        """ Convert a token generated by recursion to a flat list of
        tokens. Returns a list.
        """
        out = []
        for c in token.children:
            # for tokens with matching token types
            if c.token_type == token.token_type:
                # use those without children
                if not c.has_under():
                    out.append(c)
                # flatten those with children
                else:
                    out.extend(self.flatten_list(c))
            # otherwise keep the child
            else:
                out.append(self.flatten(c))
        return out

    def flatten(self, token=None):
        """ Convert tokens created by recursive rules into a flat token.
        For example, a token created by the rule "a := b a | b" might
        create a token with the structure "a -> b a -> b", where "->"
        denotes children of tokens. The flatten would convert this to a
        token with children "a -> b b".
        """
        if not token:
            token = self.root
        # create a new token with same type
        new = Token(token_type=token.token_type, text=token.text)
        # replace children with flattened children
        new.children = self.flatten_list(token)
        return new

    def tokens(self, token=None, aggregate=None, as_str=False):
        """ Generate an ordered list of the lowest-level child tokens
        beneath the given token. In general, these should all be literal
        expressions.

        Use the aggregate option to specify a list of token types that
        should not be broken up. For example, 'word' made up of repeated
        'alpha' tokens is probably more useful as it is, rather than
        being given as a series of individual letters. Note that the
        TreeView may be created with a aggregate list which is used by
        default.

        Use the as_str option to return a list of strings instead of
        tokens.
        """
        if not token:
            token = self.root
        # use the TreeView aggregation if none given
        if not aggregate:
            aggregate = self.aggregate
        output = []
        for c in token.children:
            # recursively call for tokens with children
            if c.has_under() and c.token_type not in aggregate:
                output.extend(self.get_tokens(c, aggregate, as_str))
            # otherwise return the token value
            else:
                output.append(c.value() if as_str else c)
        return output
        
    def find(self, token_type, as_str=False):
        """ Search the root's children for all instances of tokens
        with the given type. Return a list of tokens, or strings if
        as_str is True.
        """
        output = []
        for c in self.iter_treeview():
            if c.token_type == token_type:
                output.append(c.value() if as_str else c)
            output.extend(c.find(token_type, as_str=as_str))
        return output
    
    def level(self, index, token=None, as_str=False):
        """ Return all tokens at the given depth. For example, 0 returns
        the root, 1 returns the roots children, 2 all grand-children and
        so on. Defaults to the root token.
        """
        if not token:
            token = self.root
        output = []
        if index == 0 or not token.has_under():
            output.append(token)
        else:
            for c in token.children:
                output.extend(self.level(index - 1, c, as_str))
        return output

    def __getattribute__(self, attr):
        """ Get attributes from self, then self.root. """
        try:
            return object.__getattribute__(self, attr)
        except AttributeError:
            if hasattr(self.root, attr):
                return getattr(self.root, attr)
        raise AttributeError('%s not found' % attr)

    def __getitem__(self, index):
        """ Return the indexed child. """
        return self.children[index]

    def __repr__(self):
        """ Show value and content of token. """
        return 'TreeView(%s: %s)' % (self.token_type, self.root.value())
